# frozen_string_literal: true

# This class provided the logic for validating dynamic fields against a map generated by DynamicFieldMap.
class DigitalObject::DynamicFieldsValidator < ActiveModel::EachValidator
  private

    def generate_errors(attribute, value, map)
      errors_for(map, value, attribute)
    end

    # Returns errors that should be recorded for any of the fields in the data given.
    # Errors include: invalid fields appearing in the data given, field values containing the wrong type of data.
    def errors_for(field_map, data, path = nil)
      errors = []

      data.each do |field_or_group_key, value|
        new_path = [path, field_or_group_key].compact.join('.')
        unless field_map.key?(field_or_group_key)
          errors.append([new_path, "is not a valid field"])
          next
        end

        field_map_subtree = field_map[field_or_group_key]
        case field_map_subtree[:type]
        when 'DynamicFieldGroup'
          errors.concat errors_for_field_group(value, new_path, field_map_subtree)
        when 'DynamicField'
          if (e = field_errors(field_map_subtree, value))
            errors.concat e.map { |i| [new_path, i] }
          end
        end
      end

      errors
    end

    # Returns any errors that are present for the field and value combination.
    #
    # @return [String] if there are errors
    # @return false if there are no errors
    def field_errors(configuration, value)
      send("errors_for_#{configuration[:field_type]}_field", configuration, value)
    end

    def errors_for_field_group(value, new_path, field_map_subtree)
      errors = []
      if value.is_a?(Array)
        errors.append([new_path, "is not repeatable"]) if !field_map_subtree['is_repeatable'] && value.length > 1

        value.each_with_index do |v, i|
          errors.concat errors_for(field_map_subtree[:children], v, "#{new_path}[#{i}]")
        end
      else
        errors.append([new_path, "must contain an array"])
      end
      errors
    end

    def errors_for_string_field(_configuration, value)
      value.is_a?(String) ? false : ['must be a string']
    end

    def errors_for_textarea_field(configuration, value)
      errors_for_string_field(configuration, value)
    end

    def errors_for_date_field(_configuration, value)
      return ['must be a string'] unless value.is_a?(String)
      return ['must be a valid EDTF date'] unless valid_edtf_date?(value)
      false
    end

    def valid_edtf_date?(value)
      return true if Date.edtf(value)

      # The EDTF library we're using doesn't currently validate YYYY-MM-XX or YYYY-XX dates,
      # so we'll add an extra check here.
      if (unknown_month_match = value.match(/^(\d{4})-XX$/))
        return true if Date.edtf(unknown_month_match[1]) # validate year
      end

      if (unknown_day_match = value.match(/^(\d{4})-(\d{2})-XX$/))
        return true if Date.edtf("#{unknown_day_match[1]}-#{unknown_day_match[2]}") # validate year and month
      end

      false
    end

    def errors_for_select_field(configuration, value)
      valid_options = JSON.parse(configuration[:select_options]).map { |option| option['value'] }
      valid_options.include?(value) ? false : ["has invalid value: '#{value}'"]
    end

    def errors_for_integer_field(_configuration, value)
      value.is_a?(Integer) ? false : ['must be an integer']
    end

    def errors_for_boolean_field(_configuration, value)
      value.is_a?(TrueClass) || value.is_a?(FalseClass) ? false : ['must be a boolean']
    end

    def errors_for_controlled_term_field(configuration, value)
      return ['must be a controlled term'] unless value.is_a?(Hash)
      return ['must contain a uri or pref_label'] unless value['uri'] || value['pref_label']

      # Check that every value provided is a core field or a valid custom field value for that vocabulary.
      custom_fields = custom_fields_for(configuration[:controlled_vocabulary])
      return ["#{configuration[:controlled_vocabulary]} is not a valid vocabulary"] if custom_fields.nil?

      valid_fields = Term::CORE_FIELDS + custom_fields

      errors = (value.keys - valid_fields).map { |f| "has invalid key, \"#{f}\" in hash" }

      errors.empty? ? false : errors
    end

    # Returns nil if vocabulary is not represented in hash
    def custom_fields_for(vocabulary)
      vocabulary_to_custom_fields_map.fetch(vocabulary, nil)
    end

    def vocabulary_to_custom_fields_map
      @vocabulary_to_custom_fields_map ||= Vocabulary.all.map { |v| [v.string_key, v.custom_fields.keys] }.to_h
    end
end
